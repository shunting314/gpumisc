# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.1.0
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


# Copyright (c) 2019-2021, NVIDIA CORPORATION. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#  * Neither the name of NVIDIA CORPORATION nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _NvRules
else:
    import _NvRules

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    r"""Proxy of C++ swig::SwigPyIterator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _NvRules.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        r"""value(SwigPyIterator self) -> PyObject *"""
        return _NvRules.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        r"""
        incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator

        Parameters
        ----------
        n: size_t

        """
        return _NvRules.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        r"""
        decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator

        Parameters
        ----------
        n: size_t

        """
        return _NvRules.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        r"""
        distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _NvRules.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        r"""
        equal(SwigPyIterator self, SwigPyIterator x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _NvRules.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        r"""copy(SwigPyIterator self) -> SwigPyIterator"""
        return _NvRules.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        r"""next(SwigPyIterator self) -> PyObject *"""
        return _NvRules.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        r"""__next__(SwigPyIterator self) -> PyObject *"""
        return _NvRules.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        r"""previous(SwigPyIterator self) -> PyObject *"""
        return _NvRules.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        r"""
        advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _NvRules.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        r"""
        __eq__(SwigPyIterator self, SwigPyIterator x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _NvRules.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        r"""
        __ne__(SwigPyIterator self, SwigPyIterator x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _NvRules.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        r"""
        __iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _NvRules.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        r"""
        __isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _NvRules.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        r"""
        __add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _NvRules.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        r"""
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _NvRules.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _NvRules:
_NvRules.SwigPyIterator_swigregister(SwigPyIterator)

class map_string_string(object):
    r"""Proxy of C++ std::map< std::string,std::string > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(map_string_string self) -> SwigPyIterator"""
        return _NvRules.map_string_string_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(map_string_string self) -> bool"""
        return _NvRules.map_string_string___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(map_string_string self) -> bool"""
        return _NvRules.map_string_string___bool__(self)

    def __len__(self) -> "std::map< std::string,std::string >::size_type":
        r"""__len__(map_string_string self) -> std::map< std::string,std::string >::size_type"""
        return _NvRules.map_string_string___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::mapped_type const &":
        r"""
        __getitem__(map_string_string self, std::map< std::string,std::string >::key_type const & key) -> std::map< std::string,std::string >::mapped_type const &

        Parameters
        ----------
        key: std::map< std::string,std::string >::key_type const &

        """
        return _NvRules.map_string_string___getitem__(self, key)

    def __delitem__(self, key: "std::map< std::string,std::string >::key_type const &") -> "void":
        r"""
        __delitem__(map_string_string self, std::map< std::string,std::string >::key_type const & key)

        Parameters
        ----------
        key: std::map< std::string,std::string >::key_type const &

        """
        return _NvRules.map_string_string___delitem__(self, key)

    def has_key(self, key: "std::map< std::string,std::string >::key_type const &") -> "bool":
        r"""
        has_key(map_string_string self, std::map< std::string,std::string >::key_type const & key) -> bool

        Parameters
        ----------
        key: std::map< std::string,std::string >::key_type const &

        """
        return _NvRules.map_string_string_has_key(self, key)

    def keys(self) -> "PyObject *":
        r"""keys(map_string_string self) -> PyObject *"""
        return _NvRules.map_string_string_keys(self)

    def values(self) -> "PyObject *":
        r"""values(map_string_string self) -> PyObject *"""
        return _NvRules.map_string_string_values(self)

    def items(self) -> "PyObject *":
        r"""items(map_string_string self) -> PyObject *"""
        return _NvRules.map_string_string_items(self)

    def __contains__(self, key: "std::map< std::string,std::string >::key_type const &") -> "bool":
        r"""
        __contains__(map_string_string self, std::map< std::string,std::string >::key_type const & key) -> bool

        Parameters
        ----------
        key: std::map< std::string,std::string >::key_type const &

        """
        return _NvRules.map_string_string___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        r"""key_iterator(map_string_string self) -> SwigPyIterator"""
        return _NvRules.map_string_string_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        r"""value_iterator(map_string_string self) -> SwigPyIterator"""
        return _NvRules.map_string_string_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(map_string_string self, std::map< std::string,std::string >::key_type const & key)

        Parameters
        ----------
        key: std::map< std::string,std::string >::key_type const &

        __setitem__(map_string_string self, std::map< std::string,std::string >::key_type const & key, std::map< std::string,std::string >::mapped_type const & x)

        Parameters
        ----------
        key: std::map< std::string,std::string >::key_type const &
        x: std::map< std::string,std::string >::mapped_type const &

        """
        return _NvRules.map_string_string___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        r"""asdict(map_string_string self) -> PyObject *"""
        return _NvRules.map_string_string_asdict(self)

    def __init__(self, *args):
        r"""
        __init__(map_string_string self, std::less< std::string > const & other) -> map_string_string

        Parameters
        ----------
        other: std::less< std::string > const &

        __init__(map_string_string self) -> map_string_string
        __init__(map_string_string self, map_string_string other) -> map_string_string

        Parameters
        ----------
        other: std::map< std::string,std::string > const &

        """
        _NvRules.map_string_string_swiginit(self, _NvRules.new_map_string_string(*args))

    def empty(self) -> "bool":
        r"""empty(map_string_string self) -> bool"""
        return _NvRules.map_string_string_empty(self)

    def size(self) -> "std::map< std::string,std::string >::size_type":
        r"""size(map_string_string self) -> std::map< std::string,std::string >::size_type"""
        return _NvRules.map_string_string_size(self)

    def swap(self, v: "map_string_string") -> "void":
        r"""
        swap(map_string_string self, map_string_string v)

        Parameters
        ----------
        v: std::map< std::string,std::string > &

        """
        return _NvRules.map_string_string_swap(self, v)

    def begin(self) -> "std::map< std::string,std::string >::iterator":
        r"""begin(map_string_string self) -> std::map< std::string,std::string >::iterator"""
        return _NvRules.map_string_string_begin(self)

    def end(self) -> "std::map< std::string,std::string >::iterator":
        r"""end(map_string_string self) -> std::map< std::string,std::string >::iterator"""
        return _NvRules.map_string_string_end(self)

    def rbegin(self) -> "std::map< std::string,std::string >::reverse_iterator":
        r"""rbegin(map_string_string self) -> std::map< std::string,std::string >::reverse_iterator"""
        return _NvRules.map_string_string_rbegin(self)

    def rend(self) -> "std::map< std::string,std::string >::reverse_iterator":
        r"""rend(map_string_string self) -> std::map< std::string,std::string >::reverse_iterator"""
        return _NvRules.map_string_string_rend(self)

    def clear(self) -> "void":
        r"""clear(map_string_string self)"""
        return _NvRules.map_string_string_clear(self)

    def get_allocator(self) -> "std::map< std::string,std::string >::allocator_type":
        r"""get_allocator(map_string_string self) -> std::map< std::string,std::string >::allocator_type"""
        return _NvRules.map_string_string_get_allocator(self)

    def count(self, x: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::size_type":
        r"""
        count(map_string_string self, std::map< std::string,std::string >::key_type const & x) -> std::map< std::string,std::string >::size_type

        Parameters
        ----------
        x: std::map< std::string,std::string >::key_type const &

        """
        return _NvRules.map_string_string_count(self, x)

    def erase(self, *args) -> "void":
        r"""
        erase(map_string_string self, std::map< std::string,std::string >::key_type const & x) -> std::map< std::string,std::string >::size_type

        Parameters
        ----------
        x: std::map< std::string,std::string >::key_type const &

        erase(map_string_string self, std::map< std::string,std::string >::iterator position)

        Parameters
        ----------
        position: std::map< std::string,std::string >::iterator

        erase(map_string_string self, std::map< std::string,std::string >::iterator first, std::map< std::string,std::string >::iterator last)

        Parameters
        ----------
        first: std::map< std::string,std::string >::iterator
        last: std::map< std::string,std::string >::iterator

        """
        return _NvRules.map_string_string_erase(self, *args)

    def find(self, x: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::iterator":
        r"""
        find(map_string_string self, std::map< std::string,std::string >::key_type const & x) -> std::map< std::string,std::string >::iterator

        Parameters
        ----------
        x: std::map< std::string,std::string >::key_type const &

        """
        return _NvRules.map_string_string_find(self, x)

    def lower_bound(self, x: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::iterator":
        r"""
        lower_bound(map_string_string self, std::map< std::string,std::string >::key_type const & x) -> std::map< std::string,std::string >::iterator

        Parameters
        ----------
        x: std::map< std::string,std::string >::key_type const &

        """
        return _NvRules.map_string_string_lower_bound(self, x)

    def upper_bound(self, x: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::iterator":
        r"""
        upper_bound(map_string_string self, std::map< std::string,std::string >::key_type const & x) -> std::map< std::string,std::string >::iterator

        Parameters
        ----------
        x: std::map< std::string,std::string >::key_type const &

        """
        return _NvRules.map_string_string_upper_bound(self, x)
    __swig_destroy__ = _NvRules.delete_map_string_string

# Register map_string_string in _NvRules:
_NvRules.map_string_string_swigregister(map_string_string)

class set_string(object):
    r"""Proxy of C++ std::set< std::string > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(set_string self) -> SwigPyIterator"""
        return _NvRules.set_string_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(set_string self) -> bool"""
        return _NvRules.set_string___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(set_string self) -> bool"""
        return _NvRules.set_string___bool__(self)

    def __len__(self) -> "std::set< std::string >::size_type":
        r"""__len__(set_string self) -> std::set< std::string >::size_type"""
        return _NvRules.set_string___len__(self)

    def append(self, x: "std::set< std::string >::value_type") -> "void":
        r"""
        append(set_string self, std::set< std::string >::value_type x)

        Parameters
        ----------
        x: std::set< std::string >::value_type

        """
        return _NvRules.set_string_append(self, x)

    def __contains__(self, x: "std::set< std::string >::value_type") -> "bool":
        r"""
        __contains__(set_string self, std::set< std::string >::value_type x) -> bool

        Parameters
        ----------
        x: std::set< std::string >::value_type

        """
        return _NvRules.set_string___contains__(self, x)

    def __getitem__(self, i: "std::set< std::string >::difference_type") -> "std::set< std::string >::value_type":
        r"""
        __getitem__(set_string self, std::set< std::string >::difference_type i) -> std::set< std::string >::value_type

        Parameters
        ----------
        i: std::set< std::string >::difference_type

        """
        return _NvRules.set_string___getitem__(self, i)

    def add(self, x: "std::set< std::string >::value_type") -> "void":
        r"""
        add(set_string self, std::set< std::string >::value_type x)

        Parameters
        ----------
        x: std::set< std::string >::value_type

        """
        return _NvRules.set_string_add(self, x)

    def discard(self, x: "std::set< std::string >::value_type") -> "void":
        r"""
        discard(set_string self, std::set< std::string >::value_type x)

        Parameters
        ----------
        x: std::set< std::string >::value_type

        """
        return _NvRules.set_string_discard(self, x)

    def __init__(self, *args):
        r"""
        __init__(set_string self, std::less< std::string > const & other) -> set_string

        Parameters
        ----------
        other: std::less< std::string > const &

        __init__(set_string self) -> set_string
        __init__(set_string self, set_string other) -> set_string

        Parameters
        ----------
        other: std::set< std::string > const &

        """
        _NvRules.set_string_swiginit(self, _NvRules.new_set_string(*args))

    def empty(self) -> "bool":
        r"""empty(set_string self) -> bool"""
        return _NvRules.set_string_empty(self)

    def size(self) -> "std::set< std::string >::size_type":
        r"""size(set_string self) -> std::set< std::string >::size_type"""
        return _NvRules.set_string_size(self)

    def clear(self) -> "void":
        r"""clear(set_string self)"""
        return _NvRules.set_string_clear(self)

    def swap(self, v: "set_string") -> "void":
        r"""
        swap(set_string self, set_string v)

        Parameters
        ----------
        v: std::set< std::string > &

        """
        return _NvRules.set_string_swap(self, v)

    def count(self, x: "std::set< std::string >::key_type const &") -> "std::set< std::string >::size_type":
        r"""
        count(set_string self, std::set< std::string >::key_type const & x) -> std::set< std::string >::size_type

        Parameters
        ----------
        x: std::set< std::string >::key_type const &

        """
        return _NvRules.set_string_count(self, x)

    def begin(self) -> "std::set< std::string >::iterator":
        r"""begin(set_string self) -> std::set< std::string >::iterator"""
        return _NvRules.set_string_begin(self)

    def end(self) -> "std::set< std::string >::iterator":
        r"""end(set_string self) -> std::set< std::string >::iterator"""
        return _NvRules.set_string_end(self)

    def rbegin(self) -> "std::set< std::string >::reverse_iterator":
        r"""rbegin(set_string self) -> std::set< std::string >::reverse_iterator"""
        return _NvRules.set_string_rbegin(self)

    def rend(self) -> "std::set< std::string >::reverse_iterator":
        r"""rend(set_string self) -> std::set< std::string >::reverse_iterator"""
        return _NvRules.set_string_rend(self)

    def erase(self, *args) -> "void":
        r"""
        erase(set_string self, std::set< std::string >::key_type const & x) -> std::set< std::string >::size_type

        Parameters
        ----------
        x: std::set< std::string >::key_type const &

        erase(set_string self, std::set< std::string >::iterator pos)

        Parameters
        ----------
        pos: std::set< std::string >::iterator

        erase(set_string self, std::set< std::string >::iterator first, std::set< std::string >::iterator last)

        Parameters
        ----------
        first: std::set< std::string >::iterator
        last: std::set< std::string >::iterator

        """
        return _NvRules.set_string_erase(self, *args)

    def find(self, x: "std::set< std::string >::key_type const &") -> "std::set< std::string >::iterator":
        r"""
        find(set_string self, std::set< std::string >::key_type const & x) -> std::set< std::string >::iterator

        Parameters
        ----------
        x: std::set< std::string >::key_type const &

        """
        return _NvRules.set_string_find(self, x)

    def lower_bound(self, x: "std::set< std::string >::key_type const &") -> "std::set< std::string >::iterator":
        r"""
        lower_bound(set_string self, std::set< std::string >::key_type const & x) -> std::set< std::string >::iterator

        Parameters
        ----------
        x: std::set< std::string >::key_type const &

        """
        return _NvRules.set_string_lower_bound(self, x)

    def upper_bound(self, x: "std::set< std::string >::key_type const &") -> "std::set< std::string >::iterator":
        r"""
        upper_bound(set_string self, std::set< std::string >::key_type const & x) -> std::set< std::string >::iterator

        Parameters
        ----------
        x: std::set< std::string >::key_type const &

        """
        return _NvRules.set_string_upper_bound(self, x)

    def equal_range(self, x: "std::set< std::string >::key_type const &") -> "std::pair< std::set< std::string >::iterator,std::set< std::string >::iterator >":
        r"""
        equal_range(set_string self, std::set< std::string >::key_type const & x) -> std::pair< std::set< std::string >::iterator,std::set< std::string >::iterator >

        Parameters
        ----------
        x: std::set< std::string >::key_type const &

        """
        return _NvRules.set_string_equal_range(self, x)

    def insert(self, __x: "std::set< std::string >::value_type const &") -> "std::pair< std::set< std::string >::iterator,bool >":
        r"""
        insert(set_string self, std::set< std::string >::value_type const & __x) -> std::pair< std::set< std::string >::iterator,bool >

        Parameters
        ----------
        __x: std::set< std::string >::value_type const &

        """
        return _NvRules.set_string_insert(self, __x)
    __swig_destroy__ = _NvRules.delete_set_string

# Register set_string in _NvRules:
_NvRules.set_string_swigregister(set_string)

class set_ull(object):
    r"""Proxy of C++ std::set< unsigned long long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(set_ull self) -> SwigPyIterator"""
        return _NvRules.set_ull_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(set_ull self) -> bool"""
        return _NvRules.set_ull___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(set_ull self) -> bool"""
        return _NvRules.set_ull___bool__(self)

    def __len__(self) -> "std::set< unsigned long long >::size_type":
        r"""__len__(set_ull self) -> std::set< unsigned long long >::size_type"""
        return _NvRules.set_ull___len__(self)

    def append(self, x: "std::set< unsigned long long >::value_type") -> "void":
        r"""
        append(set_ull self, std::set< unsigned long long >::value_type x)

        Parameters
        ----------
        x: std::set< unsigned long long >::value_type

        """
        return _NvRules.set_ull_append(self, x)

    def __contains__(self, x: "std::set< unsigned long long >::value_type") -> "bool":
        r"""
        __contains__(set_ull self, std::set< unsigned long long >::value_type x) -> bool

        Parameters
        ----------
        x: std::set< unsigned long long >::value_type

        """
        return _NvRules.set_ull___contains__(self, x)

    def __getitem__(self, i: "std::set< unsigned long long >::difference_type") -> "std::set< unsigned long long >::value_type":
        r"""
        __getitem__(set_ull self, std::set< unsigned long long >::difference_type i) -> std::set< unsigned long long >::value_type

        Parameters
        ----------
        i: std::set< unsigned long long >::difference_type

        """
        return _NvRules.set_ull___getitem__(self, i)

    def add(self, x: "std::set< unsigned long long >::value_type") -> "void":
        r"""
        add(set_ull self, std::set< unsigned long long >::value_type x)

        Parameters
        ----------
        x: std::set< unsigned long long >::value_type

        """
        return _NvRules.set_ull_add(self, x)

    def discard(self, x: "std::set< unsigned long long >::value_type") -> "void":
        r"""
        discard(set_ull self, std::set< unsigned long long >::value_type x)

        Parameters
        ----------
        x: std::set< unsigned long long >::value_type

        """
        return _NvRules.set_ull_discard(self, x)

    def __init__(self, *args):
        r"""
        __init__(set_ull self, std::less< unsigned long long > const & other) -> set_ull

        Parameters
        ----------
        other: std::less< unsigned long long > const &

        __init__(set_ull self) -> set_ull
        __init__(set_ull self, set_ull other) -> set_ull

        Parameters
        ----------
        other: std::set< unsigned long long > const &

        """
        _NvRules.set_ull_swiginit(self, _NvRules.new_set_ull(*args))

    def empty(self) -> "bool":
        r"""empty(set_ull self) -> bool"""
        return _NvRules.set_ull_empty(self)

    def size(self) -> "std::set< unsigned long long >::size_type":
        r"""size(set_ull self) -> std::set< unsigned long long >::size_type"""
        return _NvRules.set_ull_size(self)

    def clear(self) -> "void":
        r"""clear(set_ull self)"""
        return _NvRules.set_ull_clear(self)

    def swap(self, v: "set_ull") -> "void":
        r"""
        swap(set_ull self, set_ull v)

        Parameters
        ----------
        v: std::set< unsigned long long > &

        """
        return _NvRules.set_ull_swap(self, v)

    def count(self, x: "std::set< unsigned long long >::key_type const &") -> "std::set< unsigned long long >::size_type":
        r"""
        count(set_ull self, std::set< unsigned long long >::key_type const & x) -> std::set< unsigned long long >::size_type

        Parameters
        ----------
        x: std::set< unsigned long long >::key_type const &

        """
        return _NvRules.set_ull_count(self, x)

    def begin(self) -> "std::set< unsigned long long >::iterator":
        r"""begin(set_ull self) -> std::set< unsigned long long >::iterator"""
        return _NvRules.set_ull_begin(self)

    def end(self) -> "std::set< unsigned long long >::iterator":
        r"""end(set_ull self) -> std::set< unsigned long long >::iterator"""
        return _NvRules.set_ull_end(self)

    def rbegin(self) -> "std::set< unsigned long long >::reverse_iterator":
        r"""rbegin(set_ull self) -> std::set< unsigned long long >::reverse_iterator"""
        return _NvRules.set_ull_rbegin(self)

    def rend(self) -> "std::set< unsigned long long >::reverse_iterator":
        r"""rend(set_ull self) -> std::set< unsigned long long >::reverse_iterator"""
        return _NvRules.set_ull_rend(self)

    def erase(self, *args) -> "void":
        r"""
        erase(set_ull self, std::set< unsigned long long >::key_type const & x) -> std::set< unsigned long long >::size_type

        Parameters
        ----------
        x: std::set< unsigned long long >::key_type const &

        erase(set_ull self, std::set< unsigned long long >::iterator pos)

        Parameters
        ----------
        pos: std::set< unsigned long long >::iterator

        erase(set_ull self, std::set< unsigned long long >::iterator first, std::set< unsigned long long >::iterator last)

        Parameters
        ----------
        first: std::set< unsigned long long >::iterator
        last: std::set< unsigned long long >::iterator

        """
        return _NvRules.set_ull_erase(self, *args)

    def find(self, x: "std::set< unsigned long long >::key_type const &") -> "std::set< unsigned long long >::iterator":
        r"""
        find(set_ull self, std::set< unsigned long long >::key_type const & x) -> std::set< unsigned long long >::iterator

        Parameters
        ----------
        x: std::set< unsigned long long >::key_type const &

        """
        return _NvRules.set_ull_find(self, x)

    def lower_bound(self, x: "std::set< unsigned long long >::key_type const &") -> "std::set< unsigned long long >::iterator":
        r"""
        lower_bound(set_ull self, std::set< unsigned long long >::key_type const & x) -> std::set< unsigned long long >::iterator

        Parameters
        ----------
        x: std::set< unsigned long long >::key_type const &

        """
        return _NvRules.set_ull_lower_bound(self, x)

    def upper_bound(self, x: "std::set< unsigned long long >::key_type const &") -> "std::set< unsigned long long >::iterator":
        r"""
        upper_bound(set_ull self, std::set< unsigned long long >::key_type const & x) -> std::set< unsigned long long >::iterator

        Parameters
        ----------
        x: std::set< unsigned long long >::key_type const &

        """
        return _NvRules.set_ull_upper_bound(self, x)

    def equal_range(self, x: "std::set< unsigned long long >::key_type const &") -> "std::pair< std::set< unsigned long long >::iterator,std::set< unsigned long long >::iterator >":
        r"""
        equal_range(set_ull self, std::set< unsigned long long >::key_type const & x) -> std::pair< std::set< unsigned long long >::iterator,std::set< unsigned long long >::iterator >

        Parameters
        ----------
        x: std::set< unsigned long long >::key_type const &

        """
        return _NvRules.set_ull_equal_range(self, x)

    def insert(self, __x: "std::set< unsigned long long >::value_type const &") -> "std::pair< std::set< unsigned long long >::iterator,bool >":
        r"""
        insert(set_ull self, std::set< unsigned long long >::value_type const & __x) -> std::pair< std::set< unsigned long long >::iterator,bool >

        Parameters
        ----------
        __x: std::set< unsigned long long >::value_type const &

        """
        return _NvRules.set_ull_insert(self, __x)
    __swig_destroy__ = _NvRules.delete_set_ull

# Register set_ull in _NvRules:
_NvRules.set_ull_swigregister(set_ull)

class vector_string(object):
    r"""Proxy of C++ std::vector< std::string > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(vector_string self) -> SwigPyIterator"""
        return _NvRules.vector_string_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(vector_string self) -> bool"""
        return _NvRules.vector_string___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(vector_string self) -> bool"""
        return _NvRules.vector_string___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type":
        r"""__len__(vector_string self) -> std::vector< std::string >::size_type"""
        return _NvRules.vector_string___len__(self)

    def __getslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "std::vector< std::string,std::allocator< std::string > > *":
        r"""
        __getslice__(vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j) -> vector_string

        Parameters
        ----------
        i: std::vector< std::string >::difference_type
        j: std::vector< std::string >::difference_type

        """
        return _NvRules.vector_string___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)

        Parameters
        ----------
        i: std::vector< std::string >::difference_type
        j: std::vector< std::string >::difference_type

        __setslice__(vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j, vector_string v)

        Parameters
        ----------
        i: std::vector< std::string >::difference_type
        j: std::vector< std::string >::difference_type
        v: std::vector< std::string,std::allocator< std::string > > const &

        """
        return _NvRules.vector_string___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "void":
        r"""
        __delslice__(vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)

        Parameters
        ----------
        i: std::vector< std::string >::difference_type
        j: std::vector< std::string >::difference_type

        """
        return _NvRules.vector_string___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(vector_string self, std::vector< std::string >::difference_type i)

        Parameters
        ----------
        i: std::vector< std::string >::difference_type

        __delitem__(vector_string self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _NvRules.vector_string___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        r"""
        __getitem__(vector_string self, PySliceObject * slice) -> vector_string

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(vector_string self, std::vector< std::string >::difference_type i) -> std::vector< std::string >::value_type const &

        Parameters
        ----------
        i: std::vector< std::string >::difference_type

        """
        return _NvRules.vector_string___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(vector_string self, PySliceObject * slice, vector_string v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< std::string,std::allocator< std::string > > const &

        __setitem__(vector_string self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::value_type const & x)

        Parameters
        ----------
        i: std::vector< std::string >::difference_type
        x: std::vector< std::string >::value_type const &

        """
        return _NvRules.vector_string___setitem__(self, *args)

    def pop(self) -> "std::vector< std::string >::value_type":
        r"""pop(vector_string self) -> std::vector< std::string >::value_type"""
        return _NvRules.vector_string_pop(self)

    def append(self, x: "std::vector< std::string >::value_type const &") -> "void":
        r"""
        append(vector_string self, std::vector< std::string >::value_type const & x)

        Parameters
        ----------
        x: std::vector< std::string >::value_type const &

        """
        return _NvRules.vector_string_append(self, x)

    def empty(self) -> "bool":
        r"""empty(vector_string self) -> bool"""
        return _NvRules.vector_string_empty(self)

    def size(self) -> "std::vector< std::string >::size_type":
        r"""size(vector_string self) -> std::vector< std::string >::size_type"""
        return _NvRules.vector_string_size(self)

    def swap(self, v: "vector_string") -> "void":
        r"""
        swap(vector_string self, vector_string v)

        Parameters
        ----------
        v: std::vector< std::string > &

        """
        return _NvRules.vector_string_swap(self, v)

    def begin(self) -> "std::vector< std::string >::iterator":
        r"""begin(vector_string self) -> std::vector< std::string >::iterator"""
        return _NvRules.vector_string_begin(self)

    def end(self) -> "std::vector< std::string >::iterator":
        r"""end(vector_string self) -> std::vector< std::string >::iterator"""
        return _NvRules.vector_string_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        r"""rbegin(vector_string self) -> std::vector< std::string >::reverse_iterator"""
        return _NvRules.vector_string_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        r"""rend(vector_string self) -> std::vector< std::string >::reverse_iterator"""
        return _NvRules.vector_string_rend(self)

    def clear(self) -> "void":
        r"""clear(vector_string self)"""
        return _NvRules.vector_string_clear(self)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        r"""get_allocator(vector_string self) -> std::vector< std::string >::allocator_type"""
        return _NvRules.vector_string_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(vector_string self)"""
        return _NvRules.vector_string_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator":
        r"""
        erase(vector_string self, std::vector< std::string >::iterator pos) -> std::vector< std::string >::iterator

        Parameters
        ----------
        pos: std::vector< std::string >::iterator

        erase(vector_string self, std::vector< std::string >::iterator first, std::vector< std::string >::iterator last) -> std::vector< std::string >::iterator

        Parameters
        ----------
        first: std::vector< std::string >::iterator
        last: std::vector< std::string >::iterator

        """
        return _NvRules.vector_string_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_string self) -> vector_string
        __init__(vector_string self, vector_string other) -> vector_string

        Parameters
        ----------
        other: std::vector< std::string > const &

        __init__(vector_string self, std::vector< std::string >::size_type size) -> vector_string

        Parameters
        ----------
        size: std::vector< std::string >::size_type

        __init__(vector_string self, std::vector< std::string >::size_type size, std::vector< std::string >::value_type const & value) -> vector_string

        Parameters
        ----------
        size: std::vector< std::string >::size_type
        value: std::vector< std::string >::value_type const &

        """
        _NvRules.vector_string_swiginit(self, _NvRules.new_vector_string(*args))

    def push_back(self, x: "std::vector< std::string >::value_type const &") -> "void":
        r"""
        push_back(vector_string self, std::vector< std::string >::value_type const & x)

        Parameters
        ----------
        x: std::vector< std::string >::value_type const &

        """
        return _NvRules.vector_string_push_back(self, x)

    def front(self) -> "std::vector< std::string >::value_type const &":
        r"""front(vector_string self) -> std::vector< std::string >::value_type const &"""
        return _NvRules.vector_string_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &":
        r"""back(vector_string self) -> std::vector< std::string >::value_type const &"""
        return _NvRules.vector_string_back(self)

    def assign(self, n: "std::vector< std::string >::size_type", x: "std::vector< std::string >::value_type const &") -> "void":
        r"""
        assign(vector_string self, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)

        Parameters
        ----------
        n: std::vector< std::string >::size_type
        x: std::vector< std::string >::value_type const &

        """
        return _NvRules.vector_string_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(vector_string self, std::vector< std::string >::size_type new_size)

        Parameters
        ----------
        new_size: std::vector< std::string >::size_type

        resize(vector_string self, std::vector< std::string >::size_type new_size, std::vector< std::string >::value_type const & x)

        Parameters
        ----------
        new_size: std::vector< std::string >::size_type
        x: std::vector< std::string >::value_type const &

        """
        return _NvRules.vector_string_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(vector_string self, std::vector< std::string >::iterator pos, std::vector< std::string >::value_type const & x) -> std::vector< std::string >::iterator

        Parameters
        ----------
        pos: std::vector< std::string >::iterator
        x: std::vector< std::string >::value_type const &

        insert(vector_string self, std::vector< std::string >::iterator pos, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)

        Parameters
        ----------
        pos: std::vector< std::string >::iterator
        n: std::vector< std::string >::size_type
        x: std::vector< std::string >::value_type const &

        """
        return _NvRules.vector_string_insert(self, *args)

    def reserve(self, n: "std::vector< std::string >::size_type") -> "void":
        r"""
        reserve(vector_string self, std::vector< std::string >::size_type n)

        Parameters
        ----------
        n: std::vector< std::string >::size_type

        """
        return _NvRules.vector_string_reserve(self, n)

    def capacity(self) -> "std::vector< std::string >::size_type":
        r"""capacity(vector_string self) -> std::vector< std::string >::size_type"""
        return _NvRules.vector_string_capacity(self)
    __swig_destroy__ = _NvRules.delete_vector_string

# Register vector_string in _NvRules:
_NvRules.vector_string_swigregister(vector_string)

class vector_ull(object):
    r"""Proxy of C++ std::vector< unsigned long long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(vector_ull self) -> SwigPyIterator"""
        return _NvRules.vector_ull_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(vector_ull self) -> bool"""
        return _NvRules.vector_ull___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(vector_ull self) -> bool"""
        return _NvRules.vector_ull___bool__(self)

    def __len__(self) -> "std::vector< unsigned long long >::size_type":
        r"""__len__(vector_ull self) -> std::vector< unsigned long long >::size_type"""
        return _NvRules.vector_ull___len__(self)

    def __getslice__(self, i: "std::vector< unsigned long long >::difference_type", j: "std::vector< unsigned long long >::difference_type") -> "std::vector< unsigned long long,std::allocator< unsigned long long > > *":
        r"""
        __getslice__(vector_ull self, std::vector< unsigned long long >::difference_type i, std::vector< unsigned long long >::difference_type j) -> vector_ull

        Parameters
        ----------
        i: std::vector< unsigned long long >::difference_type
        j: std::vector< unsigned long long >::difference_type

        """
        return _NvRules.vector_ull___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(vector_ull self, std::vector< unsigned long long >::difference_type i, std::vector< unsigned long long >::difference_type j)

        Parameters
        ----------
        i: std::vector< unsigned long long >::difference_type
        j: std::vector< unsigned long long >::difference_type

        __setslice__(vector_ull self, std::vector< unsigned long long >::difference_type i, std::vector< unsigned long long >::difference_type j, vector_ull v)

        Parameters
        ----------
        i: std::vector< unsigned long long >::difference_type
        j: std::vector< unsigned long long >::difference_type
        v: std::vector< unsigned long long,std::allocator< unsigned long long > > const &

        """
        return _NvRules.vector_ull___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< unsigned long long >::difference_type", j: "std::vector< unsigned long long >::difference_type") -> "void":
        r"""
        __delslice__(vector_ull self, std::vector< unsigned long long >::difference_type i, std::vector< unsigned long long >::difference_type j)

        Parameters
        ----------
        i: std::vector< unsigned long long >::difference_type
        j: std::vector< unsigned long long >::difference_type

        """
        return _NvRules.vector_ull___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(vector_ull self, std::vector< unsigned long long >::difference_type i)

        Parameters
        ----------
        i: std::vector< unsigned long long >::difference_type

        __delitem__(vector_ull self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _NvRules.vector_ull___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned long long >::value_type const &":
        r"""
        __getitem__(vector_ull self, PySliceObject * slice) -> vector_ull

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(vector_ull self, std::vector< unsigned long long >::difference_type i) -> std::vector< unsigned long long >::value_type const &

        Parameters
        ----------
        i: std::vector< unsigned long long >::difference_type

        """
        return _NvRules.vector_ull___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(vector_ull self, PySliceObject * slice, vector_ull v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< unsigned long long,std::allocator< unsigned long long > > const &

        __setitem__(vector_ull self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(vector_ull self, std::vector< unsigned long long >::difference_type i, std::vector< unsigned long long >::value_type const & x)

        Parameters
        ----------
        i: std::vector< unsigned long long >::difference_type
        x: std::vector< unsigned long long >::value_type const &

        """
        return _NvRules.vector_ull___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned long long >::value_type":
        r"""pop(vector_ull self) -> std::vector< unsigned long long >::value_type"""
        return _NvRules.vector_ull_pop(self)

    def append(self, x: "std::vector< unsigned long long >::value_type const &") -> "void":
        r"""
        append(vector_ull self, std::vector< unsigned long long >::value_type const & x)

        Parameters
        ----------
        x: std::vector< unsigned long long >::value_type const &

        """
        return _NvRules.vector_ull_append(self, x)

    def empty(self) -> "bool":
        r"""empty(vector_ull self) -> bool"""
        return _NvRules.vector_ull_empty(self)

    def size(self) -> "std::vector< unsigned long long >::size_type":
        r"""size(vector_ull self) -> std::vector< unsigned long long >::size_type"""
        return _NvRules.vector_ull_size(self)

    def swap(self, v: "vector_ull") -> "void":
        r"""
        swap(vector_ull self, vector_ull v)

        Parameters
        ----------
        v: std::vector< unsigned long long > &

        """
        return _NvRules.vector_ull_swap(self, v)

    def begin(self) -> "std::vector< unsigned long long >::iterator":
        r"""begin(vector_ull self) -> std::vector< unsigned long long >::iterator"""
        return _NvRules.vector_ull_begin(self)

    def end(self) -> "std::vector< unsigned long long >::iterator":
        r"""end(vector_ull self) -> std::vector< unsigned long long >::iterator"""
        return _NvRules.vector_ull_end(self)

    def rbegin(self) -> "std::vector< unsigned long long >::reverse_iterator":
        r"""rbegin(vector_ull self) -> std::vector< unsigned long long >::reverse_iterator"""
        return _NvRules.vector_ull_rbegin(self)

    def rend(self) -> "std::vector< unsigned long long >::reverse_iterator":
        r"""rend(vector_ull self) -> std::vector< unsigned long long >::reverse_iterator"""
        return _NvRules.vector_ull_rend(self)

    def clear(self) -> "void":
        r"""clear(vector_ull self)"""
        return _NvRules.vector_ull_clear(self)

    def get_allocator(self) -> "std::vector< unsigned long long >::allocator_type":
        r"""get_allocator(vector_ull self) -> std::vector< unsigned long long >::allocator_type"""
        return _NvRules.vector_ull_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(vector_ull self)"""
        return _NvRules.vector_ull_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned long long >::iterator":
        r"""
        erase(vector_ull self, std::vector< unsigned long long >::iterator pos) -> std::vector< unsigned long long >::iterator

        Parameters
        ----------
        pos: std::vector< unsigned long long >::iterator

        erase(vector_ull self, std::vector< unsigned long long >::iterator first, std::vector< unsigned long long >::iterator last) -> std::vector< unsigned long long >::iterator

        Parameters
        ----------
        first: std::vector< unsigned long long >::iterator
        last: std::vector< unsigned long long >::iterator

        """
        return _NvRules.vector_ull_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_ull self) -> vector_ull
        __init__(vector_ull self, vector_ull other) -> vector_ull

        Parameters
        ----------
        other: std::vector< unsigned long long > const &

        __init__(vector_ull self, std::vector< unsigned long long >::size_type size) -> vector_ull

        Parameters
        ----------
        size: std::vector< unsigned long long >::size_type

        __init__(vector_ull self, std::vector< unsigned long long >::size_type size, std::vector< unsigned long long >::value_type const & value) -> vector_ull

        Parameters
        ----------
        size: std::vector< unsigned long long >::size_type
        value: std::vector< unsigned long long >::value_type const &

        """
        _NvRules.vector_ull_swiginit(self, _NvRules.new_vector_ull(*args))

    def push_back(self, x: "std::vector< unsigned long long >::value_type const &") -> "void":
        r"""
        push_back(vector_ull self, std::vector< unsigned long long >::value_type const & x)

        Parameters
        ----------
        x: std::vector< unsigned long long >::value_type const &

        """
        return _NvRules.vector_ull_push_back(self, x)

    def front(self) -> "std::vector< unsigned long long >::value_type const &":
        r"""front(vector_ull self) -> std::vector< unsigned long long >::value_type const &"""
        return _NvRules.vector_ull_front(self)

    def back(self) -> "std::vector< unsigned long long >::value_type const &":
        r"""back(vector_ull self) -> std::vector< unsigned long long >::value_type const &"""
        return _NvRules.vector_ull_back(self)

    def assign(self, n: "std::vector< unsigned long long >::size_type", x: "std::vector< unsigned long long >::value_type const &") -> "void":
        r"""
        assign(vector_ull self, std::vector< unsigned long long >::size_type n, std::vector< unsigned long long >::value_type const & x)

        Parameters
        ----------
        n: std::vector< unsigned long long >::size_type
        x: std::vector< unsigned long long >::value_type const &

        """
        return _NvRules.vector_ull_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(vector_ull self, std::vector< unsigned long long >::size_type new_size)

        Parameters
        ----------
        new_size: std::vector< unsigned long long >::size_type

        resize(vector_ull self, std::vector< unsigned long long >::size_type new_size, std::vector< unsigned long long >::value_type const & x)

        Parameters
        ----------
        new_size: std::vector< unsigned long long >::size_type
        x: std::vector< unsigned long long >::value_type const &

        """
        return _NvRules.vector_ull_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(vector_ull self, std::vector< unsigned long long >::iterator pos, std::vector< unsigned long long >::value_type const & x) -> std::vector< unsigned long long >::iterator

        Parameters
        ----------
        pos: std::vector< unsigned long long >::iterator
        x: std::vector< unsigned long long >::value_type const &

        insert(vector_ull self, std::vector< unsigned long long >::iterator pos, std::vector< unsigned long long >::size_type n, std::vector< unsigned long long >::value_type const & x)

        Parameters
        ----------
        pos: std::vector< unsigned long long >::iterator
        n: std::vector< unsigned long long >::size_type
        x: std::vector< unsigned long long >::value_type const &

        """
        return _NvRules.vector_ull_insert(self, *args)

    def reserve(self, n: "std::vector< unsigned long long >::size_type") -> "void":
        r"""
        reserve(vector_ull self, std::vector< unsigned long long >::size_type n)

        Parameters
        ----------
        n: std::vector< unsigned long long >::size_type

        """
        return _NvRules.vector_ull_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned long long >::size_type":
        r"""capacity(vector_ull self) -> std::vector< unsigned long long >::size_type"""
        return _NvRules.vector_ull_capacity(self)
    __swig_destroy__ = _NvRules.delete_vector_ull

# Register vector_ull in _NvRules:
_NvRules.vector_ull_swigregister(vector_ull)


def require_metrics(handle, metrics):
    ev = get_evaluator(handle)
    for metric in metrics:
        ev.require_metric(metric)

def require_rules(handle, rules):
    ev = get_evaluator(handle)
    for rule in rules:
        ev.require_rule(rule)

def metric_instances(metric):
    instances = []

    for idx in range(metric.num_instances()):
        kind = metric.kind(idx)
        if (kind == IMetric.ValueKind_FLOAT) or (kind == IMetric.ValueKind_DOUBLE):
            instances.append(metric.as_double(idx))
        elif (kind == IMetric.ValueKind_UINT64) or (kind == IMetric.ValueKind_UINT32):
            instances.append(metric.as_uint64(idx))
        else:
            instances.append(metric.as_string(idx))

    return instances


def get_version(h: "NV::Rules::ContextHandle") -> "std::string":
    r"""
    get_version(NV::Rules::ContextHandle h) -> std::string

    Parameters
    ----------
    h: NV::Rules::ContextHandle

    """
    return _NvRules.get_version(h)

def get_context(h: "NV::Rules::ContextHandle") -> "NV::Rules::IContext *":
    r"""
    get_context(NV::Rules::ContextHandle h) -> IContext

    Parameters
    ----------
    h: NV::Rules::ContextHandle

    """
    return _NvRules.get_context(h)

def get_evaluator(h: "NV::Rules::ContextHandle") -> "NV::Rules::IEvaluator *":
    r"""
    get_evaluator(NV::Rules::ContextHandle h) -> IEvaluator

    Parameters
    ----------
    h: NV::Rules::ContextHandle

    """
    return _NvRules.get_evaluator(h)

def raise_exception(h: "NV::Rules::ContextHandle", msg: "char const *") -> "void":
    r"""
    raise_exception(NV::Rules::ContextHandle h, char const * msg)

    Parameters
    ----------
    h: NV::Rules::ContextHandle
    msg: char const *

    """
    return _NvRules.raise_exception(h, msg)
RuleKind_DEFAULT = _NvRules.RuleKind_DEFAULT

RuleKind_GUIDED = _NvRules.RuleKind_GUIDED

class IMetric(object):
    r"""Proxy of C++ NV::Rules::IMetric class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ValueKind_UNKNOWN = _NvRules.IMetric_ValueKind_UNKNOWN
    
    ValueKind_ANY = _NvRules.IMetric_ValueKind_ANY
    
    ValueKind_STRING = _NvRules.IMetric_ValueKind_STRING
    
    ValueKind_FLOAT = _NvRules.IMetric_ValueKind_FLOAT
    
    ValueKind_DOUBLE = _NvRules.IMetric_ValueKind_DOUBLE
    
    ValueKind_UINT32 = _NvRules.IMetric_ValueKind_UINT32
    
    ValueKind_UINT64 = _NvRules.IMetric_ValueKind_UINT64
    
    MetricType_OTHER = _NvRules.IMetric_MetricType_OTHER
    
    MetricType_COUNTER = _NvRules.IMetric_MetricType_COUNTER
    
    MetricType_RATIO = _NvRules.IMetric_MetricType_RATIO
    
    MetricType_THROUGHPUT = _NvRules.IMetric_MetricType_THROUGHPUT
    
    MetricSubtype_NONE = _NvRules.IMetric_MetricSubtype_NONE
    
    MetricSubtype_PEAK_SUSTAINED = _NvRules.IMetric_MetricSubtype_PEAK_SUSTAINED
    
    MetricSubtype_PEAK_SUSTAINED_ACTIVE = _NvRules.IMetric_MetricSubtype_PEAK_SUSTAINED_ACTIVE
    
    MetricSubtype_PEAK_SUSTAINED_ACTIVE_PER_SECOND = _NvRules.IMetric_MetricSubtype_PEAK_SUSTAINED_ACTIVE_PER_SECOND
    
    MetricSubtype_PEAK_SUSTAINED_ELAPSED = _NvRules.IMetric_MetricSubtype_PEAK_SUSTAINED_ELAPSED
    
    MetricSubtype_PEAK_SUSTAINED_ELAPSED_PER_SECOND = _NvRules.IMetric_MetricSubtype_PEAK_SUSTAINED_ELAPSED_PER_SECOND
    
    MetricSubtype_PEAK_SUSTAINED_FRAME = _NvRules.IMetric_MetricSubtype_PEAK_SUSTAINED_FRAME
    
    MetricSubtype_PEAK_SUSTAINED_FRAME_PER_SECOND = _NvRules.IMetric_MetricSubtype_PEAK_SUSTAINED_FRAME_PER_SECOND
    
    MetricSubtype_PEAK_SUSTAINED_REGION = _NvRules.IMetric_MetricSubtype_PEAK_SUSTAINED_REGION
    
    MetricSubtype_PEAK_SUSTAINED_REGION_PER_SECOND = _NvRules.IMetric_MetricSubtype_PEAK_SUSTAINED_REGION_PER_SECOND
    
    MetricSubtype_PER_CYCLE_ACTIVE = _NvRules.IMetric_MetricSubtype_PER_CYCLE_ACTIVE
    
    MetricSubtype_PER_CYCLE_ELAPSED = _NvRules.IMetric_MetricSubtype_PER_CYCLE_ELAPSED
    
    MetricSubtype_PER_CYCLE_IN_FRAME = _NvRules.IMetric_MetricSubtype_PER_CYCLE_IN_FRAME
    
    MetricSubtype_PER_CYCLE_IN_REGION = _NvRules.IMetric_MetricSubtype_PER_CYCLE_IN_REGION
    
    MetricSubtype_PER_SECOND = _NvRules.IMetric_MetricSubtype_PER_SECOND
    
    MetricSubtype_PCT_OF_PEAK_SUSTAINED_ACTIVE = _NvRules.IMetric_MetricSubtype_PCT_OF_PEAK_SUSTAINED_ACTIVE
    
    MetricSubtype_PCT_OF_PEAK_SUSTAINED_ELAPSED = _NvRules.IMetric_MetricSubtype_PCT_OF_PEAK_SUSTAINED_ELAPSED
    
    MetricSubtype_PCT_OF_PEAK_SUSTAINED_FRAME = _NvRules.IMetric_MetricSubtype_PCT_OF_PEAK_SUSTAINED_FRAME
    
    MetricSubtype_PCT_OF_PEAK_SUSTAINED_REGION = _NvRules.IMetric_MetricSubtype_PCT_OF_PEAK_SUSTAINED_REGION
    
    MetricSubtype_MAX_RATE = _NvRules.IMetric_MetricSubtype_MAX_RATE
    
    MetricSubtype_PCT = _NvRules.IMetric_MetricSubtype_PCT
    
    MetricSubtype_RATIO = _NvRules.IMetric_MetricSubtype_RATIO
    
    RollupOperation_NONE = _NvRules.IMetric_RollupOperation_NONE
    
    RollupOperation_AVG = _NvRules.IMetric_RollupOperation_AVG
    
    RollupOperation_MAX = _NvRules.IMetric_RollupOperation_MAX
    
    RollupOperation_MIN = _NvRules.IMetric_RollupOperation_MIN
    
    RollupOperation_SUM = _NvRules.IMetric_RollupOperation_SUM
    
    __swig_destroy__ = _NvRules.delete_IMetric

    def name(self) -> "char const *":
        r"""name(IMetric self) -> char const *"""
        return _NvRules.IMetric_name(self)

    def metric_type(self) -> "NV::Rules::IMetric::MetricType":
        r"""metric_type(IMetric self) -> NV::Rules::IMetric::MetricType"""
        return _NvRules.IMetric_metric_type(self)

    def metric_subtype(self) -> "NV::Rules::IMetric::MetricSubtype":
        r"""metric_subtype(IMetric self) -> NV::Rules::IMetric::MetricSubtype"""
        return _NvRules.IMetric_metric_subtype(self)

    def rollup_operation(self) -> "NV::Rules::IMetric::RollupOperation":
        r"""rollup_operation(IMetric self) -> NV::Rules::IMetric::RollupOperation"""
        return _NvRules.IMetric_rollup_operation(self)

    def unit(self) -> "NV::Rules::IMetric::Unit":
        r"""unit(IMetric self) -> NV::Rules::IMetric::Unit"""
        return _NvRules.IMetric_unit(self)

    def description(self) -> "NV::Rules::IMetric::Description":
        r"""description(IMetric self) -> NV::Rules::IMetric::Description"""
        return _NvRules.IMetric_description(self)

    def kind(self, *args) -> "NV::Rules::IMetric::ValueKind":
        r"""
        kind(IMetric self) -> NV::Rules::IMetric::ValueKind
        kind(IMetric self, size_t instance) -> NV::Rules::IMetric::ValueKind

        Parameters
        ----------
        instance: size_t

        """
        return _NvRules.IMetric_kind(self, *args)

    def has_value(self, *args) -> "bool":
        r"""
        has_value(IMetric self) -> bool
        has_value(IMetric self, NV::Rules::IMetric::ValueKind value_kind) -> bool

        Parameters
        ----------
        value_kind: enum NV::Rules::IMetric::ValueKind

        """
        return _NvRules.IMetric_has_value(self, *args)

    def as_double(self, *args) -> "double":
        r"""
        as_double(IMetric self) -> double
        as_double(IMetric self, size_t instance) -> double

        Parameters
        ----------
        instance: size_t

        """
        return _NvRules.IMetric_as_double(self, *args)

    def as_uint64(self, *args) -> "uint64_t":
        r"""
        as_uint64(IMetric self) -> uint64_t
        as_uint64(IMetric self, size_t instance) -> uint64_t

        Parameters
        ----------
        instance: size_t

        """
        return _NvRules.IMetric_as_uint64(self, *args)

    def as_string(self, *args) -> "char const *":
        r"""
        as_string(IMetric self) -> char const
        as_string(IMetric self, size_t instance) -> char const *

        Parameters
        ----------
        instance: size_t

        """
        return _NvRules.IMetric_as_string(self, *args)

    def num_instances(self) -> "size_t":
        r"""num_instances(IMetric self) -> size_t"""
        return _NvRules.IMetric_num_instances(self)

    def has_correlation_ids(self) -> "bool":
        r"""has_correlation_ids(IMetric self) -> bool"""
        return _NvRules.IMetric_has_correlation_ids(self)

    def correlation_ids(self) -> "NV::Rules::IMetric *":
        r"""correlation_ids(IMetric self) -> IMetric"""
        return _NvRules.IMetric_correlation_ids(self)

# Register IMetric in _NvRules:
_NvRules.IMetric_swigregister(IMetric)

class ISourceInfo(object):
    r"""Proxy of C++ NV::Rules::ISourceInfo class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _NvRules.delete_ISourceInfo

    def file_name(self) -> "char const *":
        r"""file_name(ISourceInfo self) -> char const *"""
        return _NvRules.ISourceInfo_file_name(self)

    def line(self) -> "uint32_t":
        r"""line(ISourceInfo self) -> uint32_t"""
        return _NvRules.ISourceInfo_line(self)

# Register ISourceInfo in _NvRules:
_NvRules.ISourceInfo_swigregister(ISourceInfo)

class INvtxRange(object):
    r"""Proxy of C++ NV::Rules::INvtxRange class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    PayloadType_PAYLOAD_UNKNOWN = _NvRules.INvtxRange_PayloadType_PAYLOAD_UNKNOWN
    
    PayloadType_PAYLOAD_UINT64 = _NvRules.INvtxRange_PayloadType_PAYLOAD_UINT64
    
    PayloadType_PAYLOAD_INT64 = _NvRules.INvtxRange_PayloadType_PAYLOAD_INT64
    
    PayloadType_PAYLOAD_DOUBLE = _NvRules.INvtxRange_PayloadType_PAYLOAD_DOUBLE
    
    PayloadType_PAYLOAD_UINT32 = _NvRules.INvtxRange_PayloadType_PAYLOAD_UINT32
    
    PayloadType_PAYLOAD_INT32 = _NvRules.INvtxRange_PayloadType_PAYLOAD_INT32
    
    PayloadType_PAYLOAD_FLOAT = _NvRules.INvtxRange_PayloadType_PAYLOAD_FLOAT
    
    PayloadType_PAYLOAD_JSON = _NvRules.INvtxRange_PayloadType_PAYLOAD_JSON
    
    __swig_destroy__ = _NvRules.delete_INvtxRange

    def name(self) -> "std::string":
        r"""name(INvtxRange self) -> std::string"""
        return _NvRules.INvtxRange_name(self)

    def has_attributes(self) -> "bool":
        r"""has_attributes(INvtxRange self) -> bool"""
        return _NvRules.INvtxRange_has_attributes(self)

    def category(self) -> "uint32_t":
        r"""category(INvtxRange self) -> uint32_t"""
        return _NvRules.INvtxRange_category(self)

    def color(self) -> "uint32_t":
        r"""color(INvtxRange self) -> uint32_t"""
        return _NvRules.INvtxRange_color(self)

    def payload_type(self) -> "NV::Rules::INvtxRange::PayloadType":
        r"""payload_type(INvtxRange self) -> NV::Rules::INvtxRange::PayloadType"""
        return _NvRules.INvtxRange_payload_type(self)

    def payload_as_uint64(self) -> "uint64_t":
        r"""payload_as_uint64(INvtxRange self) -> uint64_t"""
        return _NvRules.INvtxRange_payload_as_uint64(self)

    def payload_as_double(self) -> "double":
        r"""payload_as_double(INvtxRange self) -> double"""
        return _NvRules.INvtxRange_payload_as_double(self)

    def payload_as_string(self) -> "std::string":
        r"""payload_as_string(INvtxRange self) -> std::string"""
        return _NvRules.INvtxRange_payload_as_string(self)

    def message(self) -> "std::string":
        r"""message(INvtxRange self) -> std::string"""
        return _NvRules.INvtxRange_message(self)

# Register INvtxRange in _NvRules:
_NvRules.INvtxRange_swigregister(INvtxRange)

class INvtxDomainInfo(object):
    r"""Proxy of C++ NV::Rules::INvtxDomainInfo class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _NvRules.delete_INvtxDomainInfo

    def name(self) -> "std::string":
        r"""name(INvtxDomainInfo self) -> std::string"""
        return _NvRules.INvtxDomainInfo_name(self)

    def push_pop_ranges(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""push_pop_ranges(INvtxDomainInfo self) -> vector_string"""
        return _NvRules.INvtxDomainInfo_push_pop_ranges(self)

    def push_pop_range(self, idx: "size_t") -> "NV::Rules::INvtxRange *":
        r"""
        push_pop_range(INvtxDomainInfo self, size_t idx) -> INvtxRange

        Parameters
        ----------
        idx: size_t

        """
        return _NvRules.INvtxDomainInfo_push_pop_range(self, idx)

    def start_end_ranges(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""start_end_ranges(INvtxDomainInfo self) -> vector_string"""
        return _NvRules.INvtxDomainInfo_start_end_ranges(self)

    def start_end_range(self, idx: "size_t") -> "NV::Rules::INvtxRange *":
        r"""
        start_end_range(INvtxDomainInfo self, size_t idx) -> INvtxRange

        Parameters
        ----------
        idx: size_t

        """
        return _NvRules.INvtxDomainInfo_start_end_range(self, idx)

# Register INvtxDomainInfo in _NvRules:
_NvRules.INvtxDomainInfo_swigregister(INvtxDomainInfo)

class INvtxState(object):
    r"""Proxy of C++ NV::Rules::INvtxState class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _NvRules.delete_INvtxState

    def domains(self) -> "std::vector< unsigned long long,std::allocator< unsigned long long > >":
        r"""domains(INvtxState self) -> vector_ull"""
        return _NvRules.INvtxState_domains(self)

    def domain_by_id(self, id: "unsigned long long") -> "NV::Rules::INvtxDomainInfo *":
        r"""
        domain_by_id(INvtxState self, unsigned long long id) -> INvtxDomainInfo

        Parameters
        ----------
        id: unsigned long long

        """
        return _NvRules.INvtxState_domain_by_id(self, id)

# Register INvtxState in _NvRules:
_NvRules.INvtxState_swigregister(INvtxState)

class IAction(object):
    r"""Proxy of C++ NV::Rules::IAction class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    NameBase_FUNCTION = _NvRules.IAction_NameBase_FUNCTION
    
    NameBase_DEMANGLED = _NvRules.IAction_NameBase_DEMANGLED
    
    NameBase_MANGLED = _NvRules.IAction_NameBase_MANGLED
    
    __swig_destroy__ = _NvRules.delete_IAction

    def name(self, *args) -> "char const *":
        r"""
        name(IAction self, NV::Rules::IAction::NameBase base=FUNCTION) -> char const

        Parameters
        ----------
        base: enum NV::Rules::IAction::NameBase

        """
        return _NvRules.IAction_name(self, *args)

    def metric_by_name(self, metric_name: "char const *") -> "NV::Rules::IMetric *":
        r"""
        metric_by_name(IAction self, char const * metric_name) -> IMetric

        Parameters
        ----------
        metric_name: char const *

        """
        return _NvRules.IAction_metric_by_name(self, metric_name)

    def metric_names(self) -> "std::set< std::string,std::less< std::string >,std::allocator< std::string > >":
        r"""metric_names(IAction self) -> set_string"""
        return _NvRules.IAction_metric_names(self)

    def add_integer_metric(self, value_name: "char const *", value_kind: "NV::Rules::IMetric::ValueKind", value: "uint64_t") -> "NV::Rules::IMetric *":
        r"""
        add_integer_metric(IAction self, char const * value_name, NV::Rules::IMetric::ValueKind value_kind, uint64_t value) -> IMetric

        Parameters
        ----------
        value_name: char const *
        value_kind: enum NV::Rules::IMetric::ValueKind
        value: uint64_t

        """
        return _NvRules.IAction_add_integer_metric(self, value_name, value_kind, value)

    def add_double_metric(self, value_name: "char const *", value_kind: "NV::Rules::IMetric::ValueKind", value: "double") -> "NV::Rules::IMetric *":
        r"""
        add_double_metric(IAction self, char const * value_name, NV::Rules::IMetric::ValueKind value_kind, double value) -> IMetric

        Parameters
        ----------
        value_name: char const *
        value_kind: enum NV::Rules::IMetric::ValueKind
        value: double

        """
        return _NvRules.IAction_add_double_metric(self, value_name, value_kind, value)

    def add_string_metric(self, value_name: "char const *", value_kind: "NV::Rules::IMetric::ValueKind", value: "char const *") -> "NV::Rules::IMetric *":
        r"""
        add_string_metric(IAction self, char const * value_name, NV::Rules::IMetric::ValueKind value_kind, char const * value) -> IMetric

        Parameters
        ----------
        value_name: char const *
        value_kind: enum NV::Rules::IMetric::ValueKind
        value: char const *

        """
        return _NvRules.IAction_add_string_metric(self, value_name, value_kind, value)

    def source_info(self, address: "uint64_t") -> "NV::Rules::ISourceInfo *":
        r"""
        source_info(IAction self, uint64_t address) -> ISourceInfo

        Parameters
        ----------
        address: uint64_t

        """
        return _NvRules.IAction_source_info(self, address)

    def source_files(self) -> "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >":
        r"""source_files(IAction self) -> map_string_string"""
        return _NvRules.IAction_source_files(self)

    def sass_by_pc(self, address: "uint64_t") -> "std::string":
        r"""
        sass_by_pc(IAction self, uint64_t address) -> std::string

        Parameters
        ----------
        address: uint64_t

        """
        return _NvRules.IAction_sass_by_pc(self, address)

    def nvtx_state(self) -> "NV::Rules::INvtxState *":
        r"""nvtx_state(IAction self) -> INvtxState"""
        return _NvRules.IAction_nvtx_state(self)

    def ptx_by_pc(self, address: "uint64_t") -> "std::string":
        r"""
        ptx_by_pc(IAction self, uint64_t address) -> std::string

        Parameters
        ----------
        address: uint64_t

        """
        return _NvRules.IAction_ptx_by_pc(self, address)

# Register IAction in _NvRules:
_NvRules.IAction_swigregister(IAction)

class IRange(object):
    r"""Proxy of C++ NV::Rules::IRange class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _NvRules.delete_IRange

    def num_actions(self) -> "size_t":
        r"""num_actions(IRange self) -> size_t"""
        return _NvRules.IRange_num_actions(self)

    def action_by_idx(self, idx: "size_t") -> "NV::Rules::IAction *":
        r"""
        action_by_idx(IRange self, size_t idx) -> IAction

        Parameters
        ----------
        idx: size_t

        """
        return _NvRules.IRange_action_by_idx(self, idx)

    def actions_by_nvtx(self, includes: "vector_string", excludes: "vector_string") -> "std::set< unsigned long long,std::less< unsigned long long >,std::allocator< unsigned long long > >":
        r"""
        actions_by_nvtx(IRange self, vector_string includes, vector_string excludes) -> set_ull

        Parameters
        ----------
        includes: std::vector< std::string,std::allocator< std::string > > const &
        excludes: std::vector< std::string,std::allocator< std::string > > const &

        """
        return _NvRules.IRange_actions_by_nvtx(self, includes, excludes)

# Register IRange in _NvRules:
_NvRules.IRange_swigregister(IRange)

class IFrontend(object):
    r"""Proxy of C++ NV::Rules::IFrontend class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    MsgType_MSG_NONE = _NvRules.IFrontend_MsgType_MSG_NONE
    
    MsgType_MSG_OK = _NvRules.IFrontend_MsgType_MSG_OK
    
    MsgType_MSG_WARNING = _NvRules.IFrontend_MsgType_MSG_WARNING
    
    MsgType_MSG_ERROR = _NvRules.IFrontend_MsgType_MSG_ERROR
    
    Severity_SEVERITY_DEFAULT = _NvRules.IFrontend_Severity_SEVERITY_DEFAULT
    
    Severity_SEVERITY_LOW = _NvRules.IFrontend_Severity_SEVERITY_LOW
    
    Severity_SEVERITY_HIGH = _NvRules.IFrontend_Severity_SEVERITY_HIGH
    
    __swig_destroy__ = _NvRules.delete_IFrontend

    def message(self, *args) -> "int":
        r"""
        message(IFrontend self, char const * str, char const * name=None) -> int

        Parameters
        ----------
        str: char const *
        name: char const *

        message(IFrontend self, NV::Rules::IFrontend::MsgType type, char const * str, char const * name=None) -> int

        Parameters
        ----------
        type: enum NV::Rules::IFrontend::MsgType
        str: char const *
        name: char const *

        """
        return _NvRules.IFrontend_message(self, *args)

    def focus_metric(self, message_id: "int", metric_name: "char const *", metric_value: "double", severity: "NV::Rules::IFrontend::Severity", info: "char const *") -> "bool":
        r"""
        focus_metric(IFrontend self, int message_id, char const * metric_name, double metric_value, NV::Rules::IFrontend::Severity severity, char const * info) -> bool

        Parameters
        ----------
        message_id: int
        metric_name: char const *
        metric_value: double
        severity: enum NV::Rules::IFrontend::Severity
        info: char const *

        """
        return _NvRules.IFrontend_focus_metric(self, message_id, metric_name, metric_value, severity, info)

    def load_chart_from_file(self, filename: "char const *") -> "void":
        r"""
        load_chart_from_file(IFrontend self, char const * filename)

        Parameters
        ----------
        filename: char const *

        """
        return _NvRules.IFrontend_load_chart_from_file(self, filename)

# Register IFrontend in _NvRules:
_NvRules.IFrontend_swigregister(IFrontend)

class IBaseContext(object):
    r"""Proxy of C++ NV::Rules::IBaseContext class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _NvRules.delete_IBaseContext

    def handle_exception(self, msg: "char const *") -> "bool":
        r"""
        handle_exception(IBaseContext self, char const * msg) -> bool

        Parameters
        ----------
        msg: char const *

        """
        return _NvRules.IBaseContext_handle_exception(self, msg)

    def get_version(self) -> "std::string":
        r"""get_version(IBaseContext self) -> std::string"""
        return _NvRules.IBaseContext_get_version(self)

# Register IBaseContext in _NvRules:
_NvRules.IBaseContext_swigregister(IBaseContext)

class IController(object):
    r"""Proxy of C++ NV::Rules::IController class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _NvRules.delete_IController

    def propose_rule(self, rule: "char const *") -> "void":
        r"""
        propose_rule(IController self, char const * rule)

        Parameters
        ----------
        rule: char const *

        """
        return _NvRules.IController_propose_rule(self, rule)

# Register IController in _NvRules:
_NvRules.IController_swigregister(IController)

class IEvaluator(IBaseContext):
    r"""Proxy of C++ NV::Rules::IEvaluator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _NvRules.delete_IEvaluator

    def require_metric(self, metric: "char const *") -> "void":
        r"""
        require_metric(IEvaluator self, char const * metric)

        Parameters
        ----------
        metric: char const *

        """
        return _NvRules.IEvaluator_require_metric(self, metric)

    def require_rule(self, rule: "char const *") -> "void":
        r"""
        require_rule(IEvaluator self, char const * rule)

        Parameters
        ----------
        rule: char const *

        """
        return _NvRules.IEvaluator_require_rule(self, rule)

# Register IEvaluator in _NvRules:
_NvRules.IEvaluator_swigregister(IEvaluator)

class IContext(IBaseContext):
    r"""Proxy of C++ NV::Rules::IContext class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _NvRules.delete_IContext

    def controller(self) -> "NV::Rules::IController *":
        r"""controller(IContext self) -> IController"""
        return _NvRules.IContext_controller(self)

    def frontend(self) -> "NV::Rules::IFrontend *":
        r"""frontend(IContext self) -> IFrontend"""
        return _NvRules.IContext_frontend(self)

    def num_ranges(self) -> "size_t":
        r"""num_ranges(IContext self) -> size_t"""
        return _NvRules.IContext_num_ranges(self)

    def range_by_idx(self, idx: "size_t") -> "NV::Rules::IRange *":
        r"""
        range_by_idx(IContext self, size_t idx) -> IRange

        Parameters
        ----------
        idx: size_t

        """
        return _NvRules.IContext_range_by_idx(self, idx)

# Register IContext in _NvRules:
_NvRules.IContext_swigregister(IContext)



